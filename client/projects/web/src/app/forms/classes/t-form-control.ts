import { AbstractControlOptions, AsyncValidatorFn, FormControl, ValidatorFn, Validators } from '@angular/forms';
import { Observable, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { FormHelperService } from '../services/form-helper/form-helper.service';
import { FormState, TAbstractControl, UpdateValueOptions } from './t-abstract-control';

/**
 * A typed version of the built-in `FormControl`.
 * @extends FormControl
 * @param T The type of the contained data.
 * @param A The alternative type of the contained data, which will be converted to type T.
 */
export class TFormControl<T, A = any> extends FormControl {

  /**
   * The current value contained within this `TFormControl`.
   */
  readonly value: T;

  /**
   * An observable that emits the value of this `TFormControl` each time it changes in the UI or programmatically.
   * Also emits an event each time you call `enable()` or `disable()` without passing in the `emitEvent: false` option.
   */
  readonly valueChanges: Observable<T>;

  /**
   * A subject that will be used to trigger cleanup for contained observables on a call to `destory()`.
   */
  private readonly _destroySubject$ = new Subject();

  /**
   * A value converter object that is used to automatically convert a value that is set within `valueConvertControl`
   * to the expect value/format within this `TFormControl` and vice-versa.
   */
  private _valueConverter: ValueConverter<A, T>;

  /**
   * Creates a new `TFormControl` instance.
   * @param formState The initial value, or an object that contains the initial value and disabled state.
   * @param validatorOrOpts A synchronous validator function, an array of such functions,
   * or an `AbstractControlOptions` object that contains validation functions and a validation trigger.
   * @param asyncValidator A single async validator or array of async validator functions.
   * @param valueConverter A value converter that will be used to transform values set in `valueConvertControl`
   * to the value that will be present within this form control and vice-versa.
   */
  constructor(
    formState?: FormState<T>,
    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions,
    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[],
    valueConverter?: ValueConverter<A, T>
  ) {
    super(formState, validatorOrOpts, asyncValidator);
    this.registerValueConverter(valueConverter);
  }

  /**
   * A form control that holds the result of an intermediate conversion if one is configured.
   * For example, if a string -> number conversion is configured, then this will hold the string value.
   */
  get valueConvertControl(): TAbstractControl<A> {
    return this._valueConverter?.valueConvertControl;
  }

  /**
   * An observable that shall be used to trigger cleanup of other observables via the `takeUntil` pipe.
   */
  protected get _destroy$(): Observable<any> {
    return this._destroySubject$.asObservable();
  }

  /**
   * Checks the validity of this `TFormControl`. In doing so, marks it as `touched`.
   * @return true if this form control passes its validaiton tests, false otherwise.
   */
  checkValidity(): boolean {
    this.markAllAsTouched();
    return this.valid;
  }

  /**
   * Triggers the default cleanup of any observables that were generated by calls to `onValueChanges()`
   * which were supplied with the default argument for the `$destroy` observable.
   */
  destroy(): void {
    this._destroySubject$.next();
  }

  /**
   * Gets an observable that emits the value of this `TFormControl` whenever its value chagnes in the UI or programatically.
   * Also, emits an event each time you call `enable()` or `disable()` on this control without `emitEvent: false`.
   * @param destroy$ An observable that, when fired, will cause the returned observable to complete.
   * If not supplied, then a default internal observable will be used. It will be triggered when the `destory()` method is invoked.
   * @return An observable that emits the value of this form control when its value changes.
   * This observable will automatically be completed when the `destroy$` input emits.
   */
  onValueChanges(destroy$: Observable<any> = this._destroy$): Observable<T> {
    return this.valueChanges.pipe(
      takeUntil(destroy$)
    );
  }

  /**
   * Patches the value of a control.
   *
   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.
   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and
   * `FormArrays`, where it does behave differently.
   *
   * @see `setValue` for parameter docs.
   */
  patchValue(value: T, options?: SetFormControlOptions): void {
    super.patchValue(value, options);
  }

  /**
   * Registers a value converter, which will be used to convert a value set within `valueConvertControl`
   * to a specific value/type that is expected in this form control and vice-versa.
   * @param converter The value converter to register.
   */
  registerValueConverter(converter: ValueConverter<A, T>): void {
    if (converter) {
      // Set value converter, and initialize default `valueConvertControl` if not provided.
      this._valueConverter = converter;
      if (!this._valueConverter.valueConvertControl) {
        this._valueConverter.valueConvertControl = new TFormControl<A>();
      }

      // Use `FormHelperService` to map control statuses and validation over.
      const formHelperService: FormHelperService = this._valueConverter.formHelperService;
      formHelperService.mapControlStatuses(this, this.valueConvertControl);
      if (formHelperService.hasRequiredValidator(this) && !formHelperService.hasRequiredValidator(this.valueConvertControl)) {
        this.valueConvertControl.setValidators(Validators.required);
      }

      // Perform the conversion whenever a change occurs in the `valueConvertControl` or this control.
      this.valueConvertControl.valueChanges.pipe(takeUntil(this._destroy$)).subscribe((value: any) =>
        this.setValue(this._valueConverter.convert(value))
      );
      this.onValueChanges().subscribe((value: any) =>
        this.valueConvertControl.setValue(this._valueConverter.unconvert(value), { emitEvent: false })
      );

      // Ensure that if a value is initialized in the FormControl, it is unconverted and set within the valueConvertControl.
      this.valueConvertControl.setValue(this._valueConverter.unconvert(this.value), { emitEvent: false });
    }
  }

  /**
   * Resets the form control to a specified value/state. Marks it `pristine` and `untouched`.
   * @param formState Resets the control with a value, or an object that defines the value and disabled state. Defaults to undefined.
   * @param options Configuration options that determine how the control propagates changes and emits events after the value changes.
   *
   * - `onlySelf`: When true, each change only affects this control, and not its parent. Default is false.
   * - `emitEvent`: When true or not supplied (the default), both the `statusChanges` and `valueChanges` observables
   * emit events with the latest status and value when the control is reset. When false, no events are emitted.
   *
   */
  reset(formState?: FormState<T>, options?: UpdateValueOptions): void {
    super.reset(formState, options);
  }

  /**
   * Sets a new value for the form control.
   * @param value The new value for the control.
   * @param options Configuration options that determine how the control propagates changes and emits events when the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   *
   * - `onlySelf`: When true, each change only affects this control, and not its parent. Default is false.
   * - `emitEvent`: When true or not supplied (the default), both the `statusChanges` and `valueChanges` observables emit events with
   * the latest status and value when the control value is updated. When false, no events are emitted.
   * - `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an `onChange` event to update the view.
   * - `emitViewToModelChange`: When true or not supplied (the default), each change triggers an `ngModelChange` event to update the model.
   */
  setValue(value: T, options?: SetFormControlOptions): void {
    super.setValue(value, options);
  }
}

export interface SetFormControlOptions extends UpdateValueOptions {
  emitModelToViewChange?: boolean;
  emitViewToModelChange?: boolean;
}

/**
 * A value converter, which is used to automatically convert a value that is set within `valueConvertControl`
 * to the expect value/format within this `TFormControl` and vice-versa.
 */
export interface ValueConverter<A, T> {
  convert: (value: A) => T;
  unconvert: (value: T) => A;

  formHelperService: FormHelperService,
  valueConvertControl?: TAbstractControl<A>;
}

// Enhance type declaration for FormControl.
declare module '@angular/forms' {
  interface FormControl {
    readonly valueConvertControl: TAbstractControl<any>;
    checkValidity(): boolean;
    destory(): void;
    onValueChanges(destroy$?: Observable<any>): Observable<any>;
    registerValueConverter(converter: ValueConverter<any, any>): void;
  }
}

// Add extra methods to basic FormControl so that it is fully compaitble with TFormControl.
FormControl.prototype.checkValidity = TFormControl.prototype.checkValidity;
FormControl.prototype.destory = TFormControl.prototype.destroy;
FormControl.prototype.onValueChanges = TFormControl.prototype.onValueChanges;
FormControl.prototype.registerValueConverter = TFormControl.prototype.registerValueConverter;

Object.defineProperty(FormControl.prototype, 'valueConvertControl', { get: function() {
  return this._valueConverter?.valueConvertControl;
}});

Object.defineProperty(FormControl.prototype, '_destroySubject$', {
  get: function(): Subject<any> {
    if (!this.__destroySubject$) {
      this.__destroySubject$ = new Subject();
    }
    return this.__destroySubject$;
  },
  set: function(destroySubject$: Subject<any>) {
    this.__destroySubject$ = destroySubject$;
  }
});

Object.defineProperty(FormControl.prototype, '_destroy$', { get: function() {
  return this._destroySubject$.asObservable();
}});
